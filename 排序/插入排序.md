![!\[alt text\](image.png)](https://pic.leetcode.cn/1724130387-qxfMwx-Insertion-sort-example-300px.gif)

好的！我来详细讲解**插入排序**，特别是针对链表的实现。

## 插入排序基本思想

插入排序就像**整理扑克牌**：
- 你手里有一些牌（已排序部分）
- 每次从牌堆里拿一张新牌（未排序部分）
- 把这张新牌插入到手里正确的位置

## 数组的插入排序

```cpp
// 数组版本的插入排序
void insertionSort(vector<int>& arr) {
    for(int i = 1; i < arr.size(); i++) {
        int key = arr[i];  // 当前要插入的元素
        int j = i - 1;
        
        // 在已排序部分中找到插入位置
        while(j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];  // 向后移动元素
            j--;
        }
        arr[j + 1] = key;  // 插入到正确位置
    }
}
```

## 链表的插入排序

链表不能像数组那样随机访问，所以实现方式不同：

### 算法步骤
1. **创建虚拟头节点** - 方便在头部插入
2. **遍历原链表** - 每次处理一个节点
3. **在已排序部分中找到插入位置**
4. **插入节点** - 调整指针

### 代码实现（简单）
```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        ListNode dummy(0);  // 虚拟头节点
        ListNode* cur = head;
        
        while(cur) {
            ListNode* next = cur->next;  // 保存下一个节点
            ListNode* pre = &dummy;      // 从虚拟头开始找插入位置
            
            // 找到插入位置：第一个大于等于当前节点值的位置的前面
            while(pre->next && pre->next->val < cur->val) {
                pre = pre->next;
            }
            
            // 插入节点
            cur->next = pre->next;
            pre->next = cur;
            
            cur = next;  // 处理下一个节点
        }
        
        return dummy.next;
    }
};
```

### 代码实现（加入已排序last指针）
```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if (!head || !head->next) return head;
        
        ListNode dummy(0);
        dummy.next = head;
        ListNode* last = head;  // 已排序部分的最后一个节点
        ListNode* cur = head->next;
        
        while(cur) {
            ListNode* next = cur->next;  // 保存下一个节点
            
            if(cur->val >= last->val) {
                // 如果当前节点比已排序部分最后一个节点大，直接接在后面
                last->next = cur;
                last = cur;
            } else {
                // 需要在已排序部分中找到合适的插入位置
                ListNode* pre = &dummy;
                while(pre->next && pre->next->val < cur->val) {
                    pre = pre->next;
                }
                // 插入当前节点
                last->next = cur->next;  // 从原位置移除
                cur->next = pre->next;
                pre->next = cur;
            }
            
            cur = next;  // 移动到下一个节点
        }
        
        return dummy.next;
    }
};
```


## 时间复杂度分析

- **最好情况**（已排序）：O(n)
- **最坏情况**（逆序）：O(n²)
- **平均情况**：O(n²)

## 空间复杂度
- O(1) - 只使用了常数级别的额外空间

## 关键点总结

1. **虚拟头节点**：简化在头部插入的逻辑
2. **保存next指针**：因为插入操作会改变cur->next
3. **双指针技巧**：pre指针在已排序部分中寻找插入位置
4. **指针操作**：经典的链表插入操作

插入排序对于链表来说是很合适的选择，因为链表的插入操作是O(1)时间复杂度的！